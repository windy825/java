# JAVA 시작 코스



- **운영체제와 프로그램**

  - `Operating System OS`

    시스템 하드웨어를 관리하고 프로그램을 실행, 사용자와 상호작용하는 역할 수행

    하기 위해 하드웨어 추상화 플랫폼과 공통 서비스를 제공하는 시스템 소프트웨어

    ```
    추상화 플랫폼? 
    >>> 특정 어떤 하드웨어 만을 위한 서비스가 아니라, 
    	하드웨어들의 속성과 공통적인 특징들을 추상화하여 포괄적으로 공통 서비스를 제공
    	
    	만약 해당 os가 제공하지 않는 서비스 분야?? 드라이버(하드웨어를 인지할 수 있는)
    	를 설치하여 사용
    	
    	결론 
    			1. 하드웨어 명령어 가 os가 원하는 입력 규격을 맞춰서 생산하던가
    			2. 해당 규격을 os에게 알려주던가
    ```

  - `Program (=sftware)`

    컴퓨터에서 실행될 때 특정 작업을 수행하는 일련의 명령어들의 모음 (집합)

    

- **프로그래밍 단계**

  ```
  java 원시 프로그램    >    자바 바이트 코드    >    각 운영체제(mac,linux, window)
  
      hello.java    >JDK>   hello.class    >JVM>       OS 
  ```

  - **jvm** : 자바 바이트코드를 실행할 수 있는 주체

  - 자바 바이트코드는 플랫폼에 독립적이며 모든 자바 가상 머신은 

    자바 가상 머신 규격에 정의된 대로 자바 바이트코드를 실행 

    

- **Write Once Run Anywhere**



- **Garbage Collection** 더 이상 사용하지 않는 메모리를 자동으로 정리하는 기능



- **OOP IS A.P.I.E** 객체지향 4특징 (Abstraction, Polymorphism, Inheritance, Encapsulation)



- **Type** (데이터의 종류)

  - `Primitive Type` 미리 정해진 memory size, 변수 자체에 값 저장

    - ```
      논리형  boolean                     true/false
      
      정수형  byte     1byte/ 8bit        -2^7  ~ 2^7-1
             short    2byte/16bit        -2^15 ~ 2^15-1
             int(기본) 4byte/32bit        -2^31 ~ 2^31-1
             long     8byte/64bit        -2^63 ~ 2^63-1
      
      실수형  float    4byte/32bit        float f  = 0.123456789
          double(기본) 8byte/64bit        double d = 0.1234567890123456789;
      
      문자형  char     2byte/16bit        \u0000 ~ \uffff (0 ~ 2^16-1)
      ```

  - `Reference Type` 크기가 미리 정해질 수 없음, 변수에 값을 참조하는 주소 저장

  

- **연산자의 종류**

  ```
  연산자 : 연산을 수행하는 기호
  피연산자 : 연산자의 연산 수행 대상
  "모든 연산자는 연산결과를 반환한다."
  ```

  |    종류     |        연산자        |              설명              |
  | :---------: | :------------------: | :----------------------------: |
  | 산술 연산자 |   + - * / % << >>    |     사칙연산, 나머지, 비트     |
  | 비교 연산자 |   > < >= <= == !=    |      대소 비교, 같고 다름      |
  | 논리 연산자 |  && \|\| ! & \| ^ ~  |        and,or,not, 비트        |
  | 대입 연산자 |          =           |    우변의 값을 좌변에 저장     |
  |    기타     | (type) ?: instanceof | 형변환, 삼항(조건), 객체지향쪽 |

   

- **문자형**  (`'0'`하나는 문자형,   `"000"` 0개 이상은 문자열)

  - 기억할 ASCII 코드

    | 이진법  | 십진볍 | 문자 |
    | :-----: | :----: | :--: |
    | 0110000 |   48   | '0'  |
    | 1000001 |   65   | 'A'  |
    | 1100001 |   97   | 'a'  |



- 실수 계산은 정확하지 않다 >>> 반드시 반올림 신경쓰기

  ```java
  float f1 - 2.0f;
  float f2 = 1.1f;
  float f3 = f1 - f2;
  System.out.println(f3);  # 0.9
      
  double d1 = 2.0;
  double d2 = 1.1;
  double d3 = d1 - d2;
  System.out.printin(d3);  # 0.8999999999999
  ```

  ```java
  ((int)(d1*100) - (int)(d2*100)) / 100.0;  # 1. 수면위로 끌어올리기
  
  BigDeciaml b1 = new BigDecimal("2.0");    # 2. BigDecimal 로 정밀하게 실수 표현
  BigDeciaml b2 = new BigDecimal("1.1");
  b1.subtract(b2);          
  ```

  **BigDecimal 기본 용어**

  - `precision`: 숫자를 구성하는 전체 자리수라고 생각하면 편하나, 정확하게 풀이하면 왼쪽부터 0이 아닌 수가 시작하는 위치부터 오른쪽부터 0이 아닌 수로 끝나는 위치까지의 총 자리수이다. `unscale`과 동의어이다. (ex: 012345.67890의 **precision**은 11이 아닌 9이다.)
  - `scale`: 전체 소수점 자리수라고 생각하면 편하나, 정확하게 풀이하면 소수점 첫째 자리부터 오른쪽부터 0이 아닌 수로 끝나는 위치까지의 총 소수점 자리수이다. `fraction`과 동의어이다. (ex: 012345.67890의 **scale**은 4이다. 하지만 0.00, 0.0의 **scale**은 모두 1이다.) **BigDecimal**은 **32bit**의 소수점 크기를 가진다.
  - `DECIMAL128`: **IEEE 754-2008**에 의해 표준화된, 부호와 소수점을 수용하며, 최대 34자리까지 표현 가능한 10진수를 저장할 수 있는 형식이다. 2018년 미국 정부의 총 부채액이 15조 7천 500억 달러로 총 14자리 임을 감안하면, 금융권에서 처리되는 대부분의 금액을 수용할 수 있는 크기이다. **Java**에서는 **BigDecimal** 타입을 통해 공식적으로 지원한다.

